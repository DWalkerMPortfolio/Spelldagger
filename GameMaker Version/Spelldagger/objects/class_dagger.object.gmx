<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_daggerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///variables
controller=0
drawX=0
drawY=0
driftX=0
driftY=0
state="neutral"
statePrevious="neutral"
aimingDirection=0
shift=false
neutralResetPrevious=0
dir=0
distance=0
neutralXPrevious=x
neutralYPrevious=y
stuckTo=noone
stuckDirection=0
stuckAngle=0
fading=false
falling=0
rune=false

runeActivated=false
runeActivatedPrevious=runeActivated

resurrectionParticlesActivated=false

//constants
depth=1
driftSpeed=0.025
image_speed=0.2
range=150
maxSpd=50
spd=maxSpd
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///particles

emit_gust=part_emitter_create(obj_control.sys_gust)
emit_rune=part_emitter_create(obj_control.sys_rune)
emit_runeEffect=part_emitter_create(obj_control.sys_rune)
emit_resurrection=part_emitter_create(obj_control.sys_resurrection)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///noise alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///drift alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///movement + runes

//state initialization
//neutral
if state="neutral" and statePrevious="stuck"
    {
    fading=false
    x=neutralX
    y=neutralY
    stuckTo=noone
    if image_xscale&gt;0
        image_xscale=1.5
    else
        image_xscale=-1.5
    image_yscale=1.5
    image_alpha=1
    image_angle=player.image_angle
    part_type_direction(obj_control.part_gust,0,359,0,0)
    part_emitter_region(obj_control.sys_gust,emit_gust,x-4,x+4,y-4,y+4,ps_shape_rectangle,ps_distr_linear)
    part_emitter_burst(obj_control.sys_gust,emit_gust,obj_control.part_gust,7.5)
    }

statePrevious=state

if obj_control.menuDisplay[playerNumber]=false
    {
    //neutral
    if state="neutral"
        {
        if image_yscale&gt;1
            {
            image_yscale-=0.0625
            if image_xscale&gt;0
                image_xscale-=0.0625
            else
                image_xscale+=0.0625
            }
        sprite_index=spr_daggerIdle
        if shift=true
            {
            move_towards_point(neutralX,neutralY,point_distance(aimingX,aimingY,neutralX,neutralY)/5)
            if point_distance(x,y,neutralX,neutralY)&lt;speed
                {
                speed=0
                shift=false
                }
            x+=neutralX-neutralXPrevious
            y+=neutralY-neutralYPrevious
            }
        else
            {
            x=neutralX
            y=neutralY
            }
        image_angle=player.image_angle
        if (obj_control.horizontalControlDeadzoneRight[playerNumber]!=0 or obj_control.verticalControlDeadzoneRight[playerNumber]!=0) and image_yscale=1
            {
            state="aiming"
            shift=true
            }
        if daggerButtonPressed=true and shift=false and image_yscale=1
            {
            state="fire"
            shift=false
            distance=0
            spd=maxSpd
            dir=player.image_angle+90
            x=player.x
            y=player.y
            sprite_index=spr_daggerFire
            }
        }
    
    //aiming
    else if state="aiming"
        {
        sprite_index=spr_daggerSpin
        aimingDirection=point_direction(x,y,x+obj_control.horizontalControlRight[playerNumber],y+obj_control.verticalControlRight[playerNumber])
        image_angle=aimingDirection-90
        if shift=true
            {
            move_towards_point(aimingX,aimingY,point_distance(neutralX,neutralY,aimingX,aimingY)/5)
            if point_distance(x,y,aimingX,aimingY)&lt;speed
                {
                speed=0
                shift=false
                }
            x+=neutralX-neutralXPrevious
            y+=neutralY-neutralYPrevious
            }
        else
            {
            x=aimingX
            y=aimingY
            }
        if obj_control.horizontalControlDeadzoneRight[playerNumber]=0 and obj_control.verticalControlDeadzoneRight[playerNumber]=0
            {
            state="neutral"
            shift=true
            }
        if daggerButtonPressed=true and shift=false and image_yscale=1
            {
            state="fire"
            distance=0
            shift=false
            dir=image_angle+90
            x=player.x
            y=player.y
            sprite_index=spr_daggerFire
            }
        }
    
    //fire  
    else if state="fire"
        {
        var xMovement=lengthdir_x(1,dir)
        var yMovement=lengthdir_y(1,dir)
        for (var moved=0; moved&lt;=spd; moved+=1)
            {
            if !place_meeting(x+xMovement,y+yMovement,class_tall) and !place_meeting(x+xMovement,y+yMovement,class_guard)
                {
                x+=xMovement
                y+=yMovement
                }
            }
        if distance&gt;=range
            {
            spd-=10
            if spd&lt;=0
                {
                state="stuck"
                sprite_index=spr_daggerIdle
                spd=maxSpd
                distance=0
                }
            }
        var xCheck=x+lengthdir_x(4,dir)
        var yCheck=y+lengthdir_y(4,dir)
        if place_meeting(xCheck,yCheck,class_tall) or place_meeting(xCheck,yCheck,class_guard)
            {
            x+=cos(degtorad(dir))*8
            y-=sin(degtorad(dir))*8
            state="stuck"
            sprite_index=spr_daggerIdle
            image_yscale=1.25
            image_xscale*=0.75
            spd=maxSpd
            distance=0
            }
        distance+=spd
        part_type_direction(obj_control.part_gust,dir,dir,0,0)
        part_emitter_region(obj_control.sys_gust,emit_gust,x-4,x+4,y-4,y+4,ps_shape_rectangle,ps_distr_linear)
        part_emitter_burst(obj_control.sys_gust,emit_gust,obj_control.part_gust,1.5)
        }
    
    //stuck      
    else if state="stuck"
        {
        if image_yscale!=1
            {
            if image_xscale&gt;0
                image_xscale+=0.125
            else if image_xscale&lt;0
                image_xscale-=0.125
            image_yscale-=0.125
            }
    
        if runeButton=true and obj_control.rune[runeNumber]=true
            {
            fading=false
            rune=true
            }
        else
            rune=false
            
        //falling
        var fallTest=false
        var fallGridIndex=0
        if point_in_rectangle(x,y,obj_control.loadX[0],obj_control.loadY[0],obj_control.loadX[0]+2*obj_control.sectorWidth,obj_control.loadY[0]+2*obj_control.sectorHeight)
            {
            fallTest=true
            fallGridIndex=0
            }
        if obj_control.players=2 and point_in_rectangle(x,y,obj_control.loadX[1],obj_control.loadY[1],obj_control.loadX[1]+2*obj_control.sectorWidth,obj_control.loadY[1]+2*obj_control.sectorHeight) 
            {
            fallTest=true
            fallGridIndex=1
            }
        if fallTest=true
            {
            if !scr_floor(x,y,fallGridIndex) and image_yscale=1
                falling=1
            if falling=1
                {
                image_yscale-=0.1
                if image_yscale=0
                    {
                    image_yscale=1
                    y-=obj_control.maxSectorY*obj_control.sectorHeight
                    falling=2
                    }
                }
            else if falling=2
                falling=0
            }
        
        //farsight
        if runeNumber=0
            {
            if runeActivated=true
                {
                view_xview[playerNumber]=x-view_wview[playerNumber]/2
                view_yview[playerNumber]=y-view_hview[playerNumber]/2
                    
                obj_control.shadowObject[playerNumber]=self
                obj_control.player[playerNumber].canMove=false
                
                part_emitter_region(obj_control.sys_farsight,obj_control.emit_farsight,view_xport[playerNumber],view_xport[playerNumber]+view_wport[playerNumber],view_yport[playerNumber],view_yport[playerNumber]+view_hport[playerNumber],ps_shape_rectangle,ps_distr_invgaussian)
                part_emitter_burst(obj_control.sys_farsight,obj_control.emit_farsight,obj_control.part_farsight,1)
                }
            else if runeActivatedPrevious=true
                {
                obj_control.shadowObject[playerNumber]=obj_control.player[playerNumber]
                obj_control.player[playerNumber].canMove=true
                }
            }
        //warp
        else if runeNumber=1
            {
            if runeActivated=true
                {
                var warp=false
                var warpTargetX=x+lengthdir_x(32,dir+180)
                var warpTargetY=y+lengthdir_y(32,dir+180)
                with(player)
                    {
                    if place_free(warpTargetX,warpTargetY)
                        warp=true
                    }
                if warp=true
                    {
                    part_emitter_region(obj_control.sys_rune,emit_runeEffect,player.x,warpTargetX,player.y,warpTargetY,ps_shape_line,ps_distr_linear)
                    part_emitter_burst(obj_control.sys_rune,emit_runeEffect,obj_control.part_rune[runeNumber],point_distance(player.x,player.y,warpTargetX,warpTargetY)/10)
                    player.warpReturnX=player.x
                    player.warpReturnY=player.y
                    player.x=warpTargetX
                    player.y=warpTargetY
                    player.warped=2
                    state="neutral"
                    scr_sound(x,y,150)
                    }
                }
            }
        //noise
        else if runeNumber=2
            {
            if rune=true and !position_meeting(x,y,class_sound) and alarm_get(1)&lt;=0
                {
                scr_sound(x+lengthdir_x(32,dir+180),y+lengthdir_y(32,dir+180),500)
                alarm_set(1,120)
                }
            if alarm_get(1)&gt;=0
                {
                var emitAngle=irandom(359)
                var emitX=x+lengthdir_x(24,emitAngle)
                var emitY=y+lengthdir_y(24,emitAngle)
                var emitDirection=point_direction(emitX,emitY,x,y)
                part_type_direction(obj_control.part_rune[runeNumber],emitDirection,emitDirection,0,0)
                part_emitter_region(obj_control.sys_rune,emit_runeEffect,emitX,emitX,emitY,emitY,ps_shape_rectangle,ps_distr_linear)
                part_emitter_burst(obj_control.sys_rune,emit_runeEffect,obj_control.part_rune[runeNumber],-5)
                part_type_direction(obj_control.part_rune[runeNumber],0,359,0.01,0)
                }
            }

        if daggerButtonPressed=true and image_yscale=1 and runeButton=false
            fading=true
        if fading=true
            image_alpha-=0.1
        else if image_alpha&lt;1
            image_alpha+=0.1
        if image_alpha=0
            state="neutral"
        }
    if state!="stuck"
        {
        rune=false
        runeActivated=false
        }
    
    //stuck to guard    
    if statePrevious="stuck" and place_meeting(x,y,class_guard)
        {
        if instance_place(x,y,class_guard).state="dead" and resurrectionParticlesActivated=false
            {
            part_emitter_region(obj_control.sys_resurrection,emit_resurrection,x,x,y,y,ps_shape_rectangle,ps_distr_linear)
            part_emitter_stream(obj_control.sys_resurrection,emit_resurrection,obj_control.part_antiResurrection,-3)
            resurrectionParticlesActivated=true
            }
         if stuckTo=noone
            {
            stuckTo=instance_place(x,y,class_guard)
            stuckDirection=point_direction(stuckTo.x,stuckTo.y,x,y)-stuckTo.shieldDirection
            stuckAngle=image_angle-stuckTo.shieldDirection
            }
        if stuckTo!=noone and instance_exists(stuckTo)
            {
            x=stuckTo.x+lengthdir_x(22,stuckDirection+stuckTo.shieldDirection)
            y=stuckTo.y+lengthdir_y(22,stuckDirection+stuckTo.shieldDirection)
            image_angle=stuckAngle+stuckTo.shieldDirection
            }
        else
            stuckTo=noone
        }
    else
        {
        stuckTo=noone
        if resurrectionParticlesActivated=true
            {
            part_emitter_stream(obj_control.sys_resurrection,emit_resurrection,obj_control.part_antiResurrection,0)
            resurrectionParticlesActivated=false
            }
        }
        
    neutralXPrevious=neutralX
    neutralYPrevious=neutralY
    
    //rune particles
    if obj_control.rune[runeNumber]=true and (!place_meeting(x,y,class_guard) or instance_place(x,y,class_guard).state!="dead")
        {
        part_emitter_region(obj_control.sys_rune,emit_rune,x-6,x+6,y-6,y+6,ps_shape_rectangle,ps_distr_gaussian)
        part_emitter_burst(obj_control.sys_rune,emit_rune,obj_control.part_rune[runeNumber],-10)
        }
    }
    
    //rune view
    runeActivatedPrevious=runeActivated
    if runeNumber=0 or runeNumber=1
        {
        if runeActivated=false
            {
            if rune=true
                {
                obj_control.fade[playerNumber]=true
                if obj_control.fadeAlpha[playerNumber]&gt;=1
                    runeActivated=true
                }
            }
        if runeActivated=true
            {
            if rune=false
                {
                obj_control.fade[playerNumber]=true
                if obj_control.fadeAlpha[playerNumber]&gt;=1
                    runeActivated=false
                }
            }
        }
    else
        runeActivated=false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///farsight particles

part_system_drawit(obj_control.sys_farsight)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///drifting
if state="neutral" or state="aiming"
    {
    if drawX=driftX and drawY=driftY and alarm_get(0)=-1
        alarm_set(0,irandom(5))
        
    if alarm_get(0)=0
        {
        driftX=irandom_range(-1,1)
        driftY=irandom_range(-1,1)
        }
        
    if drawX!=driftX or drawY!=driftY
        {
        if driftX&lt;drawX
            drawX-=driftSpeed
        else if driftX&gt;drawX
            drawX+=driftSpeed
            
        if driftY&lt;drawY
            drawY-=driftSpeed
        else if driftY&gt;drawY
            drawY+=driftSpeed
        }
    if !scr_lightCollision(player.x,player.y)
        shader_set(shd_grayscale)
    draw_sprite_ext(sprite_index,image_index,x+drawX,y+drawY,image_xscale,image_yscale,image_angle,c_white,image_alpha)
    shader_reset()
    }
else
    {
    if !scr_lightCollision(x,y)
        shader_set(shd_grayscale)
    draw_self()
    shader_reset()
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
