<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>class_wall</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///variables + particles
event_inherited()

//variables
open=false
type="normal"
solid=true
key="MISSING KEY"
state="unlocked"
GUIAlpha[0]=0
GUIAlpha[1]=0
interactable=true
initialized=false
guardOpen=false

//constants
interactRange=64
depth=-1100

//particles
emit_gust=part_emitter_create(obj_control.sys_gust)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clear door grid + destroy emitters

//clear door grid
var clearValue
for (clearValue=gridValue; clearValue&lt;ds_grid_height(obj_control.doorGrid)-1; clearValue+=1)
    {
    var clearPointValue
    for (clearPointValue=0; clearPointValue&lt;ds_grid_width(obj_control.doorGrid); clearPointValue+=1)
        ds_grid_set(obj_control.doorGrid,clearPointValue,clearValue,ds_grid_get(obj_control.doorGrid,clearPointValue,clearValue+1))
    }
if ds_grid_height(obj_control.doorGrid)-1&gt;0
    ds_grid_resize(obj_control.doorGrid,ds_grid_width(obj_control.doorGrid),ds_grid_height(obj_control.doorGrid)-1)
else
    {
    ds_grid_destroy(obj_control.doorGrid)
    obj_control.doorGrid=ds_grid_create(4,0)
    }
var testValue=gridValue
with(class_door)
    {
    if gridValue&gt;testValue
        gridValue-=1
    }
    
//destroy emitters
part_emitter_stream(obj_control.sys_interactable,emit_interactable,obj_control.part_interactable,0)
part_emitter_destroy(obj_control.sys_interactable,emit_interactable)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initialize
event_inherited()

if initialized=false
    {
    //data map
    if dataMap!=noone
        {
        if ds_map_exists(dataMap,"key.s")
            key=ds_map_find_value(dataMap,"key.s")
        if ds_map_exists(dataMap,"state.s")
            state=ds_map_find_value(dataMap,"state.s")
        }
    gridValue=ds_grid_height(obj_control.doorGrid)
    ds_grid_resize(obj_control.doorGrid,ds_grid_width(obj_control.doorGrid),ds_grid_height(obj_control.doorGrid)+1)
    if type="double"
        {
        doorCoordinates[0]=x+lengthdir_x(64,image_angle+180)
        doorCoordinates[1]=y+lengthdir_y(64,image_angle+180)
        doorCoordinates[2]=x+lengthdir_x(64,image_angle)
        doorCoordinates[3]=y+lengthdir_y(64,image_angle)
        ds_grid_set(obj_control.doorGrid,0,gridValue,doorCoordinates[0])
        ds_grid_set(obj_control.doorGrid,1,gridValue,doorCoordinates[1])
        ds_grid_set(obj_control.doorGrid,2,gridValue,doorCoordinates[2])
        ds_grid_set(obj_control.doorGrid,3,gridValue,doorCoordinates[3])
        part_emitter_region(obj_control.sys_gust,emit_gust,doorCoordinates[0],doorCoordinates[2],doorCoordinates[1],doorCoordinates[3],ps_shape_rectangle,ps_distr_linear)
        part_emitter_region(obj_control.sys_interactable,emit_interactable,doorCoordinates[0]+lengthdir_x(8,image_angle+90),doorCoordinates[2]+lengthdir_x(8,image_angle-90),doorCoordinates[1]+lengthdir_y(8,image_angle+90),doorCoordinates[3]+lengthdir_y(8,image_angle-90),ps_shape_rectangle,ps_distr_linear)
        }
    else
        {
        doorCoordinates[0]=x+lengthdir_x(32,image_angle+180)
        doorCoordinates[1]=y+lengthdir_y(32,image_angle+180)
        doorCoordinates[2]=x+lengthdir_x(32,image_angle)
        doorCoordinates[3]=y+lengthdir_y(32,image_angle)
        ds_grid_set(obj_control.doorGrid,0,gridValue,doorCoordinates[0])
        ds_grid_set(obj_control.doorGrid,1,gridValue,doorCoordinates[1])
        ds_grid_set(obj_control.doorGrid,2,gridValue,doorCoordinates[2])
        ds_grid_set(obj_control.doorGrid,3,gridValue,doorCoordinates[3])
        part_emitter_region(obj_control.sys_gust,emit_gust,doorCoordinates[0],doorCoordinates[2],doorCoordinates[1],doorCoordinates[3],ps_shape_rectangle,ps_distr_linear)
        part_emitter_region(obj_control.sys_interactable,emit_interactable,doorCoordinates[0]+lengthdir_x(8,image_angle+90),doorCoordinates[2]+lengthdir_x(8,image_angle-90),doorCoordinates[1]+lengthdir_y(8,image_angle+90),doorCoordinates[3]+lengthdir_y(8,image_angle-90),ps_shape_rectangle,ps_distr_linear)
        }
    if type="double"
        {
        openSprite=spr_doorDoubleOpen
        closedSprite=spr_doorDouble
        }
    else if type="hidden"
        {
        openSprite=spr_doorHiddenOpen
        closedSprite=spr_doorHidden
        part_emitter_stream(obj_control.sys_interactable,emit_interactable,obj_control.part_interactable,0)
        part_emitter_destroy(obj_control.sys_interactable,emit_interactable)
        }
    else if type="normal"
        {
        openSprite=spr_doorOpen
        closedSprite=spr_door
        }
    initialized=true
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///open
if interacted=true
    {
    if open=false
        {
        if ds_list_find_index(obj_control.keysCollectedList,key)!=-1
            var keyCollected=true
        else
            var keyCollected=false
        if state="enchanted" and keyCollected=false
            scr_message("Requires "+key,interactPlayer.playerNumber)
        if state="locked" and keyCollected=false
            {
            scr_sound(x,y,250,false)
            scr_message("Picked "+key+" lock",interactPlayer.playerNumber)
            state="unlocked"
            }
        if state!="enchanted" or keyCollected=true
            {
            ds_grid_set(obj_control.doorGrid,0,gridValue,0)
            ds_grid_set(obj_control.doorGrid,1,gridValue,0)
            ds_grid_set(obj_control.doorGrid,2,gridValue,0)
            ds_grid_set(obj_control.doorGrid,3,gridValue,0)
            sprite_index=openSprite
            solid=false
            if state!="unlocked" and state!="alarmed"
                {
                scr_message("Unlocked Using "+key,interactPlayer.playerNumber)
                if state!="alarmed"
                    state="unlocked"
                }
            if state="alarmed"
                {
                var alrm=instance_nearest(x,y,obj_alarm)
                if alrm!=noone
                    alrm.triggered=true
                }
            open=true
            }
        part_type_direction(obj_control.part_gust,image_angle+90,image_angle+90,0,0)
        }
    else if open=true
        {
        ds_grid_set(obj_control.doorGrid,0,gridValue,doorCoordinates[0])
        ds_grid_set(obj_control.doorGrid,1,gridValue,doorCoordinates[1])
        ds_grid_set(obj_control.doorGrid,2,gridValue,doorCoordinates[2])
        ds_grid_set(obj_control.doorGrid,3,gridValue,doorCoordinates[3])
        sprite_index=closedSprite
        solid=true
        if place_meeting(x,y,class_player)
            {
            var playerCollision=instance_place(x,y,class_player);
            if abs(angle_difference(point_direction(x,y,playerCollision.x,playerCollision.y),image_angle+90))&gt;90
                {
                playerCollision.x=x+lengthdir_x(36,image_angle-90)
                playerCollision.y=y+lengthdir_y(36,image_angle-90)
                }
            else
                {
                playerCollision.x=x+lengthdir_x(36,image_angle+90)
                playerCollision.y=y+lengthdir_y(36,image_angle+90)
                }
            }
        open=false
        part_type_direction(obj_control.part_gust,image_angle-90,image_angle-90,0,0)
        }
    part_emitter_burst(obj_control.sys_gust,emit_gust,obj_control.part_gust,10)
    }
    
//guard open
if open=false
    {
    if place_meeting(x,y,class_guard) and guardOpen=false 
        {
        ds_grid_set(obj_control.doorGrid,0,gridValue,0)
        ds_grid_set(obj_control.doorGrid,1,gridValue,0)
        ds_grid_set(obj_control.doorGrid,2,gridValue,0)
        ds_grid_set(obj_control.doorGrid,3,gridValue,0)
        sprite_index=openSprite
        solid=false
        guardOpen=true
        }
    else if collision_line(doorCoordinates[0],doorCoordinates[1],doorCoordinates[2],doorCoordinates[3],class_guard,false,true)=noone and guardOpen=true
        {
        ds_grid_set(obj_control.doorGrid,0,gridValue,doorCoordinates[0])
        ds_grid_set(obj_control.doorGrid,1,gridValue,doorCoordinates[1])
        ds_grid_set(obj_control.doorGrid,2,gridValue,doorCoordinates[2])
        ds_grid_set(obj_control.doorGrid,3,gridValue,doorCoordinates[3])
        sprite_index=closedSprite
        solid=true
        guardOpen=false
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///icon

if type!="hidden"
    {
    if collision_line(x,y,obj_control.player[view_current].x,obj_control.player[view_current].y,class_wall,true,true)=noone and open=false
        {
        GUIAlpha[view_current]+=0.1
        if GUIAlpha[view_current]&gt;0.8
            GUIAlpha[view_current]=0.8
        }
    else
        {
        GUIAlpha[view_current]-=0.1
        if GUIAlpha[view_current]&lt;0
            GUIAlpha[view_current]=0
        }
    
    if GUIAlpha[view_current]&gt;0
        {  
        draw_set_alpha(GUIAlpha[view_current])
        if state="locked"
            draw_sprite(spr_lockGUI,0,x,y)
        else if state="enchanted"
            draw_sprite(spr_lockEnchantedGUI,0,x,y)
        draw_set_alpha(1)
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///mask + draw self

if open=true and lightCollision=false
    shader_set(shd_grayscale)
draw_self()
shader_reset()
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
