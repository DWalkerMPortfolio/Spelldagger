<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_guardIdleFront</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///variables

//variables
path=path_add()
path_set_closed(path,false)
shieldDirection=direction
state="patrol"
type="guard"
group=0
spd=1
pathPoint=0
currentPatrol=0
safeDir=0
playerView=0
chaseStartX=0
chaseStartY=0
pathFail=0
playerLine=0
directionPrevious=direction
viewDirection=direction
detectPlayer=noone
chasePlayer=noone
soundX=0
soundY=0
emit_resurrection=part_emitter_create(obj_control.sys_resurrection)
emit_suspicion=part_emitter_create(obj_control.sys_suspicion)
deathAlphaDirection="decreasing"
deadDagger=noone
mpGridIndex=0
alert=false
patrolX[0]=x
patrolY[0]=y
initialized=false

//constants
solid=true
range=1
depth=0
contactRange=52
visionRange=200
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy emitters

part_emitter_destroy(obj_control.sys_resurrection,emit_resurrection)
part_emitter_destroy(obj_control.sys_suspicion,emit_suspicion)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///resurrect alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///sentry look alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///pause at patrol point alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///footstep alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initialize (patrol + type)

if initialized=false
    {
    direction=image_angle+90
    startDirection=direction
    
    //patrol
    if pathRow!=-1
        {
        for (var i=1; i&lt;ds_grid_width(obj_control.pathGrid)-1; i+=2)
            {
            var pathX=ds_grid_get(obj_control.pathGrid,i,pathRow)
            var pathY=ds_grid_get(obj_control.pathGrid,i+1,pathRow)
            if pathX!="empty"
                {
                patrolX[((i-1) div 2)+1]=pathX+x
                patrolY[((i-1) div 2)+1]=pathY+y
                }
            else
                break;
            }
        }
        
    //type
    if array_length_1d(patrolX)&lt;=1
        type="sentry"
    else
        type="guard"
    if dataMap!=noone
        {
        if ds_map_exists(dataMap,"type.s")
            type=ds_map_find_value(dataMap,"type.s")
        }
        
    //group
    if dataMap!=noone
        {
        if ds_map_exists(dataMap,"group.i")
            group=ds_map_find_value(dataMap,"group.i")
        }
    
    initialized=true
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///AI COMPLETE REWRITE?

image_angle=direction-90
speed=0

//detect player (line of sight, light, and vision cone angle)
if obj_control.players=2
    {
    if (collision_line(x,y,obj_player2.x,obj_player2.y,class_wall,true,true)=noone and scr_lightCollision(obj_player2.x,obj_player2.y) and abs((angle_difference(viewDirection,point_direction(x,y,obj_player2.x,obj_player2.y))))&lt;20) and (collision_line(x,y,obj_player1.x,obj_player1.y,class_wall,true,true)=noone and scr_lightCollision(obj_player1.x,obj_player1.y) and abs((angle_difference(viewDirection,point_direction(x,y,obj_player1.x,obj_player1.y))))&lt;20)
        {
        if instance_nearest(x,y,class_player).object_index=obj_player1
            detectPlayer=obj_player1
        else
            detectPlayer=obj_player2
        }
    else if collision_line(x,y,obj_player1.x,obj_player1.y,class_wall,true,true)=noone and scr_lightCollision(obj_player1.x,obj_player1.y) and abs((angle_difference(viewDirection,point_direction(x,y,obj_player1.x,obj_player1.y))))&lt;20
        detectPlayer=obj_player1
    else if collision_line(x,y,obj_player2.x,obj_player2.y,class_wall,true,true)=noone and scr_lightCollision(obj_player2.x,obj_player2.y) and abs((angle_difference(viewDirection,point_direction(x,y,obj_player2.x,obj_player2.y))))&lt;20
        detectPlayer=obj_player2
    else
        detectPlayer=noone
    }
else if collision_line(x,y,obj_player1.x,obj_player1.y,class_wall,true,true)=noone and scr_lightCollision(obj_player1.x,obj_player1.y) and abs((angle_difference(viewDirection,point_direction(x,y,obj_player1.x,obj_player1.y))))&lt;20
    detectPlayer=obj_player1
else
    detectPlayer=noone
    
//set grid
if obj_control.players=1 or point_in_rectangle(x,y,obj_control.sectorX[0]*obj_control.sectorWidth,(obj_control.sectorY[0]+obj_control.layer[0]*obj_control.maxSectorY)*obj_control.sectorHeight,(obj_control.sectorX[0]+1)*obj_control.sectorWidth,((obj_control.sectorY[0]+1)+obj_control.layer[0]*obj_control.maxSectorY)*obj_control.sectorHeight)
    mpGridIndex=0
else
    mpGridIndex=1
mpGrid=obj_control.mpGrid[mpGridIndex]

//states
if state!="dead"
    {
    //patrol
    if state="patrol"
        {
        //set sentry facing direction
        if type="sentry" and x=patrolX[currentPatrol] and y=patrolY[currentPatrol]
            direction=startDirection
        //set animations
        if sprite_index!=spr_guardLookFront and sprite_index!=spr_guardLookBack
            {
            if type="sentry" and x=patrolX[currentPatrol] and y=patrolY[currentPatrol] //sentry idle
                sprite_index=spr_guardIdleFront
            else if type="sentry" and sprite_index!=spr_guardMovementShieldBack //sentry moving
                sprite_index=spr_guardMovementShieldFront
            else
                sprite_index=spr_guardMovementShieldBack //patroling
            }
        //set speed
        if alert=true
            spd=1.5
        else
            spd=1.25
        image_speed=0.13
        //get next patrol point
        if (x=patrolX[currentPatrol] and y=patrolY[currentPatrol]) or path_index=-1
            {
            //look around if alert
            if alert=true and alarm_get(2)&lt;=0 and direction=image_angle+90
                {
                image_speed=0.075
                if sprite_index!=spr_guardLookFront and sprite_index!=spr_guardLookBack //start look animation
                    {
                    if type="sentry"
                        sprite_index=spr_guardLookFront
                    else
                        sprite_index=spr_guardLookBack
                    image_index=0
                    }
                else
                    {
                    if image_index&lt;2 or image_index&gt;5 //adjust view direction
                        viewDirection+=1.25
                    else
                        viewDirection-=1.25
                    if image_index=image_number-2 //end animation
                        {
                        if type="sentry"
                            sprite_index=spr_guardIdleFront
                        else
                            sprite_index=spr_guardMovementShieldBack
                        alarm_set(2,120)
                        }
                    }
                }
            //pause if not alert (MAY NOT APPLY)
            else
                {
                if alarm_get(1)&lt;0
                    alarm_set(1,30)
                else
                    {
                    if type="sentry"
                        sprite_index=spr_guardIdleFront
                    else
                        sprite_index=spr_guardIdleBack
                    }
                }
            //create next patrol path and start
            if sprite_index!=spr_guardLookFront and sprite_index!=spr_guardLookBack
                {
                if type!="sentry" and (x=patrolX[currentPatrol] and y=patrolY[currentPatrol])
                    currentPatrol+=1
                if currentPatrol&gt;array_length_1d(patrolX)-1
                    currentPatrol=0
                path_clear_points(path)
                path_add_point(path,x,y,100)
                path_add_point(path,patrolX[currentPatrol],patrolY[currentPatrol],100)
                path_start(path,spd,path_action_stop,true)
                }
            }
        //start investigating if sound is heard
        if position_meeting(x,y,class_sound)
            {
            var sound=instance_position(x,y,class_sound)
            if sound.creator!=self and sound.ignore=false
                {
                path_end()
                image_index=0
                if type="sentry"
                    sprite_index=spr_guardDrawFront
                else
                    sprite_index=spr_guardDrawBack
                soundX=sound.x
                soundY=sound.y
                state="investigate"
                }
            }
        }
    
    //investigate
    else if state="investigate"
        {
        spd=1.5
        //draw sword when beginning to investigate and generate path
        if sprite_index=spr_guardDrawFront or sprite_index=spr_guardDrawBack
            {
            image_speed=0.2
            if image_index&gt;=image_number-1
                {
                if mp_grid_path(mpGrid,path,x,y,soundX,soundY,true)=true
                    {
                    path_start(path,spd,path_action_stop,true)
                    sprite_index=spr_guardMovementSword
                    part_emitter_region(obj_control.sys_suspicion,emit_suspicion,soundX,soundX,soundY,soundY,ps_shape_rectangle,ps_distr_linear)
                    }
                else
                    state="patrol"
                }
            }
        else
            {
            //return when source of investigation is reached
            if path_index!=-1 and point_distance(x,y,path_get_x(path_index,1),path_get_y(path_index,1))&lt;=16
                {
                path_end()
                image_index=0
                sprite_index=spr_guardSheathBack
                state="return"
                }
            part_emitter_burst(obj_control.sys_suspicion,emit_suspicion,obj_control.part_suspicion,-5) //suspicion particles
            }
        }
    
    //chase
    else if state="chase"
        {
        spd=1.75
        image_speed=0.16
        //finish drawing sword
        if sprite_index=spr_guardDrawFront or sprite_index=spr_guardDrawBack
            {
            if image_index&gt;=image_number-1
                sprite_index=spr_guardMovementSword
            }
        else
            {
            //if done drawing sword and player is not in contact
            if sprite_index!=spr_guardSheathFront and sprite_index!=spr_guardSheathBack and point_distance(x,y,instance_nearest(x,y,class_player).x,instance_nearest(x,y,class_player).y)&gt;contactRange
                {
                //??? I HAVE NO CLUE WHAT THIS DOES
                if collision_line(x+lengthdir_x(8,point_direction(x,y,chasePlayer.x,chasePlayer.y)+90),y+lengthdir_y(8,point_direction(x,y,chasePlayer.x,chasePlayer.y)+90),chasePlayer.x+lengthdir_x(8,point_direction(x,y,chasePlayer.x,chasePlayer.y)+90),chasePlayer.y+lengthdir_y(8,point_direction(x,y,chasePlayer.x,chasePlayer.y)+90),class_solid,true,true)=noone and collision_line(x+lengthdir_x(8,point_direction(x,y,chasePlayer.x,chasePlayer.y)-90),y+lengthdir_y(8,point_direction(x,y,chasePlayer.x,chasePlayer.y)-90),chasePlayer.x+lengthdir_x(8,point_direction(x,y,chasePlayer.x,chasePlayer.y)-90),chasePlayer.y+lengthdir_y(8,point_direction(x,y,chasePlayer.x,chasePlayer.y)-90),class_solid,true,true)=noone and collision_line(x,y,chasePlayer.x,chasePlayer.y,class_solid,true,true)=noone and path_index=-1
                    {
                    playerLine+=1
                    if (path_index=-1 or playerLine&gt;60) and abs(angle_difference(direction,point_direction(x,y,chasePlayer.x,chasePlayer.y)))&lt;30
                        {
                        playerLine=0
                        path_end()
                        move_towards_point(chasePlayer.x,chasePlayer.y,spd)
                        }
                    else
                        {
                        path_end()
                        speed=0
                        if angle_difference(direction,point_direction(x,y,chasePlayer.x,chasePlayer.y))&gt;0
                            direction-=3
                        else
                            direction+=3
                        }
                    }
                else
                    {
                    if path_index=-1
                        {
                        if mp_grid_path(mpGrid,path,x,y,chasePlayer.x,chasePlayer.y,true)=true
                            path_start(path,spd,path_action_stop,true)
                        else
                            pathFail+=1
                        }
                    if path_position&gt;0.9 and path_index!=-1
                        {
                        if !(collision_line(x,y,chasePlayer.x,chasePlayer.y,class_wall,true,true)=noone and position_meeting(chasePlayer.x,chasePlayer.y,class_light) and abs((angle_difference(viewDirection,point_direction(x,y,chasePlayer.x,chasePlayer.y))))&lt;20 and position_meeting(chasePlayer.x,chasePlayer.y,class_light))
                            {
                            path_end()
                            safeDir=point_direction(x,y,chasePlayer.x,chasePlayer.y)+180
                            image_index=0
                            sprite_index=spr_guardSheathBack
                            state="return"
                            pathFail=0
                            }
                        else
                            path_end()
                        }
                    }
                }
            else if point_distance(x,y,instance_nearest(x,y,class_player).x,instance_nearest(x,y,class_player).y)&lt;contactRange
                {
                path_end()
                direction=point_direction(x,y,instance_nearest(x,y,class_player).x,instance_nearest(x,y,class_player).y)
                state="attack"
                image_index=0
                chasePlayer=instance_nearest(x,y,class_player)
                }
            if pathFail&gt;=10
                {
                path_end()
                image_index=0
                sprite_index=spr_guardSheathBack
                state="return"
                }
            }
        }
    
    //attack
    else if state="attack"
        {
        //if facing nearest player, attack
        if abs(angle_difference(direction,point_direction(x,y,instance_nearest(x,y,class_player).x,instance_nearest(x,y,class_player).y)))&lt;30
            {
            var attackedPlayer=instance_nearest(x,y,class_player)
            sprite_index=spr_guardAttack
            image_speed=0.2
            if image_index&gt;3 and point_distance(x,y,attackedPlayer.x,attackedPlayer.y)&lt;contactRange*1.4 //if the player was close enough, kill them
                attackedPlayer.dead=true
            if image_index&gt;image_number-1 //if the player survived, start chasing
                {
                state="chase"
                chaseStartX=x
                chaseStartY=y
                chasePlayer=attackedPlayer
                sprite_index=spr_guardMovementSword
                }
            }
        //if not facing nearest player, turn to face them
        else if angle_difference(direction,point_direction(x,y,instance_nearest(x,y,class_player).x,instance_nearest(x,y,class_player).y))&gt;0
            direction-=spd*2
        else
            direction+=spd*2
        
        } 
    //return
    if state="return"
        {
        spd=1.5
        //wait till done sheathing sword, then calculate path back THIS IS WHERE THE NEW STUFF GOES
        if sprite_index=spr_guardSheathBack
            {
            if image_index&gt;=image_number-1
                {
                sprite_index=spr_guardMovementShieldBack
                path_end()
                if mp_grid_path(mpGrid,path,x,y,clamp(patrolX[currentPatrol],obj_control.sectorX[mpGridIndex]*obj_control.sectorWidth,(obj_control.sectorX[mpGridIndex]+2)*obj_control.sectorWidth),clamp(patrolY[currentPatrol],(obj_control.sectorY[mpGridIndex]+obj_control.layer[mpGridIndex]*obj_control.maxSectorY)*obj_control.sectorHeight,(obj_control.sectorY[mpGridIndex]+2+obj_control.layer[mpGridIndex]*obj_control.maxSectorY)*obj_control.sectorHeight),true)=true
                    path_start(path,spd,path_action_stop,true)
                else
                    state="patrol"
                }
            }
        else
            {
            //if back at patrol point, return to patroling
            if path_index=-1 or (path_index!=-1 and point_distance(x,y,patrolX[currentPatrol],patrolY[currentPatrol])&lt;=spd)
                {
                path_end()
                if type="sentry"
                    {
                    if sprite_index!=spr_guardShiftShield
                        {
                        image_index=0
                        sprite_index=spr_guardShiftShield
                        }
                    else if image_index&gt;=image_number-1
                        state="patrol"
                    }
                else
                    state="patrol"
                }
            }
        }
        
    //turning (to face direction)
    if abs(angle_difference(direction,point_direction(x,y,path_get_x(path,max(path_position,0)+1/path_get_length(path)),path_get_y(path,max(path_position,0)+1/path_get_length(path)))))&gt;=2 and path_index!=-1 and state!="attack"
        {
        path_speed=0
        speed=0
        if angle_difference(direction,point_direction(x,y,path_get_x(path,max(path_position,0)+1/path_get_length(path)),path_get_y(path,max(path_position,0)+1/path_get_length(path))))&gt;0
            direction-=2
        else
            direction+=2
        }
    else
       path_speed=spd
       
    if abs(angle_difference(direction,directionPrevious))&gt;4 and path_index=-1
        {
        if angle_difference(direction,directionPrevious)&gt;0
            directionPrevious+=spd*2
        else if angle_difference(direction,directionPrevious)&lt;0
            directionPrevious-=spd*2
        direction=directionPrevious
        }
    
    //dagger (interacting with shield)
    if place_meeting(x,y,class_dagger)
        {
        var dagger=instance_place(x,y,class_dagger)
        if dagger.statePrevious="fire"
            {
            if angle_difference(shieldDirection,point_direction(x,y,dagger.x,dagger.y))&lt;-50 or angle_difference(shieldDirection,point_direction(x,y,dagger.x,dagger.y))&gt;50
                {
                script_execute(scr_sound,x,y,400,false)
                sprite_index=spr_guardDeath
                image_index=0
                alert=true
                part_emitter_region(obj_control.sys_resurrection,emit_resurrection,x,x,y,y,ps_shape_rectangle,ps_distr_linear)
                part_emitter_stream(obj_control.sys_resurrection,emit_resurrection,obj_control.part_resurrection,-2)
                deadDagger=dagger
                state="dead"
                }
            }
        }
    }

//death
else if state="dead"
    {
    //when initially killed
    if image_speed&gt;0
        {
        solid=false
        image_speed=0.2
        path_end()
        if image_index&gt;image_number-1
            {
            sprite_index=spr_guardIdleFront
            image_speed=0
            image_alpha=0
            alarm_set(3,600)
            }
        }
    else
        {
        if !place_meeting(x,y,deadDagger) and !place_meeting(x,y,class_player) //if no longer stabbed, resurrect
            {
            solid=true
            image_alpha=1
            sprite_index=spr_guardDeath
            image_speed=-0.2
            if image_index&lt;1
                {
                part_emitter_stream(obj_control.sys_resurrection,emit_resurrection,obj_control.part_resurrection,0)
                deadDagger=noone
                state="patrol"
                }
            }
        else //fade in and out
            {
            if image_alpha&gt;=0.5
                deathAlphaDirection="decreasing"
            else if image_alpha&lt;=0
                deathAlphaDirection="increasing"
            if deathAlphaDirection="decreasing"
                image_alpha-=0.01
            if deathAlphaDirection="increasing"
                image_alpha+=0.01
            }
        }
    }
    
//detection
//if in a detecting state, a player is available to view or in cantact with a player
if (state="patrol" or state="investigate" or state="return") and (detectPlayer!=noone or point_distance(x,y,instance_nearest(x,y,class_player).x,instance_nearest(x,y,class_player).y)&lt;contactRange)
    {
    //if nearest player is in contact or a player is in vision range
    if point_distance(x,y,instance_nearest(x,y,class_player).x,instance_nearest(x,y,class_player).y)&lt;contactRange or point_distance(x,y,detectPlayer.x,detectPlayer.y)&lt;visionRange
        {
        playerView+=0.1
        if playerView&gt;=1 or place_meeting(x,y,class_player)
            {
            playerView=1
            alert=true
            state="chase"
            image_index=0
            if type="sentry"
                sprite_index=spr_guardDrawFront
            else
                sprite_index=spr_guardDrawBack
            script_execute(scr_sound,x,y,400,false)
            path_end()
            chaseStartX=x
            chaseStartY=y
            if point_distance(x,y,instance_nearest(x,y,class_player).x,instance_nearest(x,y,class_player).y)&lt;contactRange
                chasePlayer=instance_nearest(x,y,class_player)
            else
                chasePlayer=detectPlayer
            }
        }
    //otheriwse, reset view
    else
        {
        playerView-=0.1
        if playerView&lt;0.5 and (alert=true or state="investigate")
            playerView=0.5
        else if playerView&lt;0
            playerView=0
        }
    }
//otherwise, reset view
else
    {
    playerView-=0.1
    if playerView&lt;1 and state="chase"
        playerView=1
    else if playerView&lt;0.5 and (alert=true or state="investigate")
        playerView=0.5
    else if playerView&lt;0
        playerView=0
    }
    
//chase reset
if state!="chase"
    {
    chaseCount=0
    pathFail=0
    playerLine=0
    }
    
//view direction
if sprite_index!=spr_guardLookFront and sprite_index!=spr_guardLookBack
    viewDirection=direction
    
//shield direction
if state!="dead"
    {
    if sprite_index=spr_guardIdleFront or sprite_index=spr_guardLookFront or sprite_index=spr_guardMovementShieldFront or sprite_index=spr_guardMovementSword
        shieldDirection=image_angle+90
    if sprite_index=spr_guardDrawFront or sprite_index=spr_guardDrawBack or sprite_index=spr_guardAttack or sprite_index=spr_guardShiftShield or sprite_index=spr_guardSheathBack or sprite_index=spr_guardSheathFront
        shieldDirection=image_angle+180
    if sprite_index=spr_guardIdleBack or sprite_index=spr_guardLookBack or sprite_index=spr_guardMovementShieldBack
        shieldDirection=image_angle+270
    }

directionPrevious=direction
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///hidden

if (collision_line(x,y,obj_control.shadowObject[0].x,obj_control.shadowObject[0].y,class_wall,true,true)!=noone and (obj_control.players=1 or collision_line(x,y,obj_control.shadowObject[1].x,obj_control.shadowObject[1].y,class_wall,true,true)!=noone)) and state!="dead"
    {
    if alarm_get(0)&lt;=0
        {
        script_execute(scr_sound,x,y,12,true)
        if state="patrol"
            alarm_set(0,150)
        else if state="investigate" or state="return"
            alarm_set(0,50)
        else if state="chase"
            alarm_set(0,25)
        }
    image_alpha-=0.1
    }
else if state!="dead"
    {
    alarm_set(0,0)
    image_alpha+=0.1  
    }  

if image_alpha&gt;1
    image_alpha=1
else if image_alpha&lt;0
    image_alpha=0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///DEBUG patrol DEACTIVATED
/*
draw_set_color(c_white)
draw_text(x,y-16,currentPatrol)
draw_text(x,y,patrolX[currentPatrol])
draw_text(x,y+16,patrolY[currentPatrol])
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///vision

if rectangle_in_rectangle(x-visionRange,y-visionRange,x+visionRange,y+visionRange,view_xview[view_current],view_yview[view_current],view_xview[view_current]+view_wview[view_current],view_yview[view_current]+view_hview[view_current])!=0
    {
    //light vision
    var localGuardVisionSurface=obj_control.guardVisionSurface[view_current]
    surface_set_target(localGuardVisionSurface)
    draw_clear_alpha(c_black,0)
    draw_set_color(merge_colour(c_yellow,c_red,playerView))
    draw_primitive_begin(pr_trianglefan)
    draw_vertex(visionRange+1,visionRange+1)
    draw_vertex(visionRange+lengthdir_x(visionRange,viewDirection-20)+1,visionRange+lengthdir_y(visionRange,viewDirection-20)+1)
    draw_vertex(visionRange+lengthdir_x(visionRange,viewDirection)+1,visionRange+lengthdir_y(visionRange,viewDirection)+1)
    draw_vertex(visionRange+lengthdir_x(visionRange,viewDirection+20)+1,visionRange+lengthdir_y(visionRange,viewDirection+20)+1)
    draw_primitive_end()
    draw_set_blend_mode(bm_subtract)
    draw_surface_part(obj_control.darkTextureSurface[view_current],x-visionRange-obj_control.sectorX[view_current]*obj_control.sectorWidth,y-visionRange-obj_control.sectorY[view_current]*obj_control.sectorHeight,visionRange*2,visionRange*2,0,0)
    draw_set_blend_mode(bm_normal)
    draw_line_width(visionRange,visionRange,visionRange+lengthdir_x(visionRange,viewDirection-20),visionRange+lengthdir_y(visionRange,viewDirection-20),1.5)
    draw_line_width(visionRange+lengthdir_x(visionRange,viewDirection-20),visionRange+lengthdir_y(visionRange,viewDirection-20),visionRange+lengthdir_x(visionRange,viewDirection),visionRange+lengthdir_y(visionRange,viewDirection),1.5)
    draw_line_width(visionRange+lengthdir_x(visionRange,viewDirection),visionRange+lengthdir_y(visionRange,viewDirection),visionRange+lengthdir_x(visionRange,viewDirection+20),visionRange+lengthdir_y(visionRange,viewDirection+20),1.5)
    draw_line_width(visionRange+lengthdir_x(visionRange,viewDirection+20),visionRange+lengthdir_y(visionRange,viewDirection+20),visionRange+lengthdir_x(5,viewDirection),visionRange+lengthdir_y(5,viewDirection),1.5)
    draw_set_color(c_black)
    draw_set_blend_mode(bm_subtract)
    scr_shadow(x,y,x-visionRange,y-visionRange,x-visionRange,y-visionRange,visionRange*2,visionRange*2,true,view_current)
    draw_set_blend_mode(bm_normal)
    surface_reset_target()
    
    var drawVision=true
    if state="dead"
        {
        if sprite_index=spr_guardDeath
            draw_set_alpha((image_number-image_index)/image_number/4)
        else
            drawVision=false
        }
    else
        draw_set_alpha(0.25)
    if drawVision=true
        {
        draw_surface(localGuardVisionSurface,x-visionRange,y-visionRange)
        draw_set_alpha(1)
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///shaders

if !scr_lightCollision(x,y)
    shader_set(shd_grayscale)
else
    {
    shader_set(shd_guard)
    var shaderGuardColorIndex=shader_get_uniform(shd_guard,"guardColorIndex")
    shader_set_uniform_f(shaderGuardColorIndex,group)
    }
draw_self()
shader_reset()
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
